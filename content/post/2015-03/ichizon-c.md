---
categories:
- ichizon
date: 2015-03-23T12:19:23+08:00
tags: []
title: "mcfog的一己之见 XII"
---

<!--================================!-->

## 如何从代码规范上避免 python 模块循环引用？

[问题](http://segmentfault.com/q/1010000002518251) by [v7](http://segmentfault.com/u/v7)

我现在会用的方法：

 1. 函数内引用
        每次在函数内引用 都感觉是因为不了解而害怕
        而且觉得有点丑           
 2. 使用 “\__all__” 白名单开放接口       
 3. 尽量避免 import ＊

抛砖引玉一下，希望引出除了技巧上还有经验上的知识。

<!--more-->


---

## 我的看法

怎么说呢，如果老是觉得碰到循环引用，很可能是模块的分界线划错地方了。可能是把应该在一起的东西硬拆开了，可能是某些职责放错地方了，可能是应该抽象的东西没抽象

总之微观代码规范可能并不能帮到太多，重要的是更宏观的划分模块的经验技巧，推荐uml，脑图，白板等等图形化的工具先梳理清楚整个系统的总体结构和职责分工

---




<!--================================!-->

## 有哪些值得一读的优秀开源 JS 代码

[问题](http://segmentfault.com/q/1010000002396706) by [bumfod](http://segmentfault.com/u/bumfod)

由这个问题启发：[如何阅读源代码？你有读过哪些源代码？晒晒你读源代码的经历……](http://segmentfault.com/q/1010000002396186)

---

## 我的看法

[Backbone][1]或者它的轻量版[Exoskeleton][2] 它教你怎么写框架，怎么组织业务逻辑
jQ读不动的话可以考虑读读[Zepto][3] 它教你怎么搞定DOM，附赠Ajax 
楼上有人提过的Underscore不错，但未来似乎是属于[lodash][4]的  它教你怎么摆平复杂数据结构

最后，虽然不是一个具体的项目，但[Github Trending][5]值得你关注，它告诉你最新最酷的项目是什么


  [1]: http://backbonejs.org/docs/backbone.html
  [2]: https://github.com/paulmillr/exoskeleton/tree/master/lib
  [3]: https://github.com/madrobby/zepto/tree/master/src
  [4]: https://github.com/lodash/lodash/blob/master/lodash.js
  [5]: https://github.com/trending?l=javascript&since=weekly

---

<!--================================!-->

## 请教一个根据时间平均划分请求的计算方法

[问题](http://segmentfault.com/q/1010000000730167) by [李惟](http://segmentfault.com/u/liwei_161273)

问题很简单：

 - 一个小时有3600秒，就以这个为单位，按照每秒来的方式发起请求
 - 如果在这个期间有36次请求，那么就是1次/100秒，如果有360次请求，就是1次/10秒

这个不难，那如果说：

 - 3600秒有19次请求，那么就是189.47次，那肯定不可能是1次/189.47秒，因为是按照秒来发起请求的，但是如果按照1次/190秒来算，那在3600秒里面肯定是完不成19次请求的，如果按照1次/188秒来算，就分配的不是特别均匀（后面还空出28秒），也就是说如何尽可能的将19均分在3600上，然后面空出的数字越少越好
 - 如果说3600秒请求7520次请求，如何能算出每秒需发起多少次请求才能平均且合理呢？
 - 如果说3600秒请求31次请求，如何能算出多少秒发起一次请求比较平均且合理呢？

---

## 我的看法

把累积的小数误差体现在后面的计算中即可消灭最后的累积误差。

也就是说每次使用“剩余时间”和“剩余次数”而非“总时间”和“总次数”来计算，这样每次向下取整，剩余时间就会变多一些，后面就更倾向于向上取整一些，反之亦然。误差会在不超过正负1的区间内摇摆而不会累积

```py

def scheduleRequest(reqCount, time = 3600):
    result = []

    remainTime = time

    for i in xrange(0, reqCount):
        t = round(remainTime / (reqCount - i))

        if(len(result) > 0):
            result.append(result[-1] + t)
        else:
            result.append(t)

        remainTime -= t

    return result

print(scheduleRequest(11))
print(scheduleRequest(12))
print(scheduleRequest(13))
print(scheduleRequest(73, 36))

```

结果（最后那个请求次数超过时间两倍的例子，为了展示方便缩减为36秒）

> [327.0, 654.0, 981.0, 1308.0, 1635.0, 1963.0, 2290.0, 2618.0, 2945.0, 3273.0, 3600.0]  
[300.0, 600.0, 900.0, 1200.0, 1500.0, 1800.0, 2100.0, 2400.0, 2700.0, 3000.0, 3300.0, 3600.0]  
[276.0, 553.0, 830.0, 1107.0, 1384.0, 1661.0, 1938.0, 2215.0, 2492.0, 2769.0, 3046.0, 3323.0, 3600.0]  
[0.0, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 5.0, 5.0, 6.0, 6.0, 7.0, 7.0, 8.0, 8.0, 9.0, 9.0, 10.0, 10.0, 11.0, 11.0, 12.0, 12.0, 13.0, 13.0, 14.0, 14.0, 15.0, 15.0, 16.0, 16.0, 17.0, 17.0, 18.0, 18.0, 19.0, 19.0, 20.0, 20.0, 21.0, 21.0, 22.0, 22.0, 23.0, 23.0, 24.0, 24.0, 25.0, 25.0, 26.0, 26.0, 27.0, 27.0, 28.0, 28.0, 29.0, 29.0, 30.0, 30.0, 31.0, 31.0, 32.0, 32.0, 33.0, 33.0, 34.0, 34.0, 35.0, 35.0, 36.0, 36.0]  

---




这是我在 [SegmentFault](http://segmentfault.com/) 上的问题回答选编，遵循[CC BY-SA 3.0 CN](http://creativecommons.org/licenses/by-sa/3.0/cn/) 分享

题图：万智【精研时序】

![](/img/2015-q1/avr81.jpg)


